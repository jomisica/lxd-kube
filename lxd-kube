#!/bin/bash

# Change directory
cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"

if [ "$EUID" -eq 0 ]; then
    echo "Please do not run as root"
    echo "Example: bash lxd-kube"
    exit
fi

if ! command -v yq &>/dev/null; then
    echo "yq could not be found"
    echo
    echo "The script makes use of the yq command to read and later edit"
    echo "the configuration files and templates used in the project."
    echo
    echo "You can install yq with snap if your system allows it:"
    echo "sudo snap install yq"
    echo
    echo "Or you can see other ways to install the command in the"
    echo "GitHub project: https://github.com/mikefarah/yq"
    exit 1
fi

MAX_WAIT_SECONDS=360
K8S_KUBE_CONFIG_ENDPOINT_USE_IP=false
DELETE_GENERATED=false
FORCE=false
CONFIG_FILE=
WAIT_CDRs=false

usage() {
    echo
    echo "Usage: lxd-kube [provision|destroy|stop|start|pause|restart] --config project-config-file.yaml --force --delete-generated"
    echo
    exit 1
}

get_lxc_profile_path() {
    if ! [ -f "$1" ]; then
        echo "projects/default/lxc/profiles/k8s.yaml"
        return 0
    fi
    echo "$1"
}

get_kubernetes_bootstrap_path() {
    if ! [ -f "$1" ]; then
        echo "projects/default/kubernetes/bootstrap/bootstrap.sh"
        return 0
    fi
    echo "$1"
}

get_kubernetes_postboot_path() {
    if ! [ -f "$1" ]; then
        echo "projects/default/kubernetes/postboot/postboot.sh"
        return 0
    fi
    echo "$1"
}

get_kubernetes_template_path() {
    if [ -f "$1" ]; then
        echo "$1"
        return 0
    fi
    echo "projects/default/kubernetes/templates/"$(basename $(dirname "$1"))"/"$(basename "$1")
}

get_projects() {
    local fields
    local IFS=,
    while read -a fields; do
        local LXD_PROJECT=$(echo "${fields[0]}" | tr -d '\n\r[:space:]')
        string_sem_current="${LXD_PROJECT//(current)/}"
        PROJECTS+=("$string_sem_current")
    done < <(lxc project list --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_profiles() {
    local fields
    local IFS=,
    while read -a fields; do
        local prof_name=$(echo "${fields[0]}" | tr -d '\n\r[:space:]')
        PROFILES+=("$prof_name")
    done < <(lxc --project "$1" profile list --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_containers() {
    local fields
    local IFS=,
    while read -a fields; do
        local prof_name=$(echo "${fields[0]}" | tr -d '\n\r[:space:]')
        CONTAINERS+=("$prof_name")
    done < <(lxc --project "$1" list --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_volumes() {
    local fields
    local IFS=,
    while read -a fields; do
        local prof_name=$(echo "${fields[1]}" | tr -d '\n\r[:space:]')
        #echo $prof_name
        VOLUMES+=("$prof_name")
    done < <(lxc --project "$1" storage volume list "$2" --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}
get_storages() {
    local fields
    local IFS=,
    while read -a fields; do
        local prof_name=$(echo "${fields[0]}" | tr -d '\n\r[:space:]')
        #echo $prof_name
        STORAGES+=("$prof_name")
    done < <(lxc --project "$1" storage list --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_container_stat() {
    local fields
    local IFS=,
    while read -a fields; do
        local STAT=$(echo "${fields[1]}" | tr -d '\n\r[:space:]')
        echo ${STAT}
    done < <(lxc --project "$1" list "$2" --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_images() {
    local fields
    local IFS=,
    while read -a fields; do
        local FINGERPRINT=$(echo "${fields[1]}" | tr -d '\n\r[:space:]')
        IMAGES+=("$FINGERPRINT")
    done < <(lxc image list --project "$1" --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

get_bridge() {
    local ret
    ret=$(lxc network list --format csv 2>/dev/null | grep "$1" 2>"logs/${PROJECT_NAME}/lxc.log")
    if [ $? -eq 0 ]; then
        return 0
    else
        return $?
    fi
}

is_cluster() {
    lxc info | grep "server_clustered: true" >"logs/${PROJECT_NAME}/lxc.log" 2>&1
    if [ $? -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

get_cluster_member() {
    local fields
    local IFS=,
    while read -a fields; do
        local MEMBERS=$(echo "${fields[0]}" | tr -d '\n\r[:space:]')
        CLUSTER_MEMBERS+=("$MEMBERS")
    done < <(lxc cluster list --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
}

is_up() {
    local fields
    local IFS=,

    t=0
    while [ $t -le $1 ]; do
        read -a fields < <(lxc --project "$2" list "$3" --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
        local running=$(echo "${fields[1]}" | tr -d '\n\r[:space:]')
        local ip=$(echo "${fields[2]}" | tr -d '\n\r[:space:]')
        ip="${ip//(eth0)/}"
        ip=${ip/\"/}

        if [ "$running" = "RUNNING" -a ! -z "$ip" ]; then
            $(lxc --project "$2" exec "$3" -- stat /root/.ssh/authorized_keys >"logs/${PROJECT_NAME}/lxc.log" 2>&1)
            if [ $? -eq 0 ]; then
                #echo "STATUS: $running"
                #echo "IP: $ip"
                #echo "------------------------------"
                sleep 1
                return 0
            fi
        fi
        sleep 1
        t=$((t + 1))
    done
    return 255
}

get_instance_ip() {
    local fields
    local IFS=,
    read -a fields < <(lxc --project "$1" list "$2" --format csv 2>"logs/${PROJECT_NAME}/lxc.log")
    local ip=$(echo "${fields[2]}" | tr -d '\n\r[:space:]')
    local justIP="${ip//(eth0)/}"
    justIP=${justIP/\"/}

    echo "$justIP"
}

is_in_array() {
    local value="$1"
    local array=("${@:2}")

    for element in "${array[@]}"; do
        if [ "$element" == "$value" ]; then
            return 0
        fi
    done

    return 1
}

lxc_stop_containers() {
    echo -e "\n## Stopping project instances...\n"
    local i=0
    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")

        echo "### Stopping container '${INSTANCE_NAME}' in project '${PROJECT_NAME}'."
        if [ $(get_container_stat "${PROJECT_NAME}" "${INSTANCE_NAME}") != "STOPPED" ]; then
            lxc --project "${PROJECT_NAME}" stop "${INSTANCE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Container stopped"
            else
                echo "#### [$?] Error stopping the container"
                exit $?
            fi
        else
            echo "#### [OK] The container is already stopped"
        fi
    done
}

lxc_start_containers() {
    echo -e "\n## Starting project instances...\n"
    local i=0
    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")

        echo "### Starting the container '${INSTANCE_NAME}' in project '${PROJECT_NAME}'."
        local stat=$(get_container_stat "${PROJECT_NAME}" "${INSTANCE_NAME}")
        if [ ${stat} = "STOPPED" ] || [ ${stat} = "FROZEN" ]; then
            lxc --project "${PROJECT_NAME}" start "${INSTANCE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Container started"
            else
                echo "#### [$?] Error starting container"
                exit $?
            fi
        else
            echo "#### [OK] The container is already started"
        fi
    done
}

lxc_pause_containers() {
    echo -e "\n## Pausing project instances...\n"
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")

        echo "### Pausing the container '${INSTANCE_NAME}' in project '${PROJECT_NAME}'."
        if [ $(get_container_stat "${PROJECT_NAME}" "${INSTANCE_NAME}") = "RUNNING" ]; then
            lxc --project "${PROJECT_NAME}" pause "${INSTANCE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Container paused"
            else
                echo "#### [$?] Error pausing the container"
                exit $?
            fi
        else
            echo "#### [OK] The container is not running"
        fi
    done
}

delete_storage_volumes() {
    echo "## Deleting storage volumes for project."
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")

        local profile_file="${LXC_GENERATED_CONFIGS_DIR}/profiles/${PROFILE_NAME}.yaml"
        #echo $profile_file
        if ! [ -f "${profile_file}" ]; then
            echo "#### [OK] Profile generated file do not exists"
            echo
            return 0
        fi

        #local PROFILE_DEVICES=$(yq e ".devices" "${profile_file}")
        #echo "${PROFILE_DEVICES}"

        local PROFILE_DEVICES_LENGTH=$(yq -r ".devices | keys | length" "${profile_file}")
        #echo "${PROFILE_DEVICES_LENGTH}"

        for ((o = 0; o < ${PROFILE_DEVICES_LENGTH}; o++)); do
            local type=$(yq -r ".devices | keys | .[$o]" "${profile_file}")
            local DEVICE_NAME=$(yq -r ".devices.${type}.type" "${profile_file}")
            if [ "x${DEVICE_NAME}" != "xdisk" ]; then
                continue
            fi

            local DEVICE_POOL=$(yq -r ".devices.${type}.pool" "${profile_file}")
            if [ "x${DEVICE_POOL}" = "xdefault" ]; then
                continue
            fi

            local DEVICE_SOURCE=$(yq -r ".devices.${type}.source" "${profile_file}")
            # if [ "x${DEVICE_POOL}" = "xdefault" ]; then
            #     continue
            # fi
            #echo $DEVICE_NAME
            #echo $DEVICE_POOL
            #echo $DEVICE_SOURCE

            local VOLUMES=()
            get_volumes "${PROJECT_NAME}" ${DEVICE_POOL}

            echo "### Deleting a storage volume ${DEVICE_SOURCE} on storage ${DEVICE_POOL}..."
            if is_in_array "${DEVICE_SOURCE}" "${VOLUMES[@]}"; then
                lxc storage volume delete "${DEVICE_POOL}" "${DEVICE_SOURCE}" --project "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
                if [ $? -eq 0 ]; then
                    echo "#### [OK] The storage volume was deleted successfully."
                else
                    echo "#### [$?] Error deleting the storage volume."
                    exit $?
                fi
            fi

        done
    done
    echo "## END Deleting storage volumes for project."
    echo
}

delete_storage() {

    local storage_directory="projects/${PROJECT_NAME}/lxc/storage"

    if ! [ -d "${storage_directory}" ]; then
        return 0
    fi

    local IFS=$(echo -en "\n\b")
    local templates=$(find "${storage_directory}" -type f | sort 2>/dev/null)
    local templates_num=$(find "${storage_directory}" -type f 2>/dev/null | wc -l)

    if [ ${templates_num} -lt 1 ]; then
        return 0
    fi

    echo "## Deleting the storages for the ${PROJECT_NAME} project..."

    for TEMPLATE in ${templates}; do

        #echo ${TEMPLATE}
        local IFS=$(echo -en "\n\b")

        local file_name=$(basename ${TEMPLATE})

        #evolve_templates "${TEMPLATE}" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}"
        if ! [ -f "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}" ]; then
            echo "#### [OK] Storage generated file do not exists"
            continue
        fi
        local STORAGE_NAME=$(yq e ".name" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}")

        unset IFS

        if [ "x${STORAGE_NAME}" = "xnull" ]; then
            echo "### [error] The storage template must contain the name of the storage to be created."
            exit 255
        fi

        local STORAGES=()
        get_storages "${PROJECT_NAME}"

        echo "### Deleting storage ${STORAGE_NAME} in the ${PROJECT_NAME} project..."
        if is_in_array "${STORAGE_NAME}" "${STORAGES[@]}"; then
            echo "#### Deleting storage ${STORAGE_NAME} in project ${PROJECT_NAME}..."
            lxc storage delete "${STORAGE_NAME}" --project "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The storage was deleted successfully."
            else
                echo "##### [$?] Error deleting storage."
                exit $?
            fi
        fi

    done
    echo "## END Deleting storage for project in LXC."

    #exit
    #lxc storage list --project "${PROJECT_NAME}"
    echo
}

create_storage() {

    local storage_directory="projects/${PROJECT_NAME}/lxc/storage"

    if ! [ -d "${storage_directory}" ]; then
        return 0
    fi

    local IFS=$(echo -en "\n\b")
    local templates=$(find "${storage_directory}" -type f | sort 2>/dev/null)
    local templates_num=$(find "${storage_directory}" -type f 2>/dev/null | wc -l)

    if [ ${templates_num} -lt 1 ]; then
        return 0
    fi

    echo "## Creating the storages for the ${PROJECT_NAME} project..."

    for TEMPLATE in ${templates}; do

        #echo ${TEMPLATE}
        local IFS=$(echo -en "\n\b")

        local file_name=$(basename ${TEMPLATE})

        evolve_templates "${TEMPLATE}" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}"

        #${TEMPLATE}

        local loopdevice=false

        local STORAGE_NAME=$(yq e ".name" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}")
        local STORAGE_DRIVER=$(yq e ".driver" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}")
        local STORAGE_SOURCE=$(yq e ".config.source" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}")
        local STORAGE_SIZE=$(yq e ".config.size" "${LXC_GENERATED_CONFIGS_DIR}/storage/${file_name}")

        unset IFS

        if [ "x${STORAGE_NAME}" = "xnull" ]; then
            echo "### [error] The storage template must contain the name of the storage to be created."
            exit 255
        fi
        if [ "x${STORAGE_DRIVER}" = "xnull" ]; then
            echo "### The storage template must contain the storage driver to be created."
            exit 255
        fi

        if [ "x${STORAGE_SOURCE}" = "xnull" ]; then
            loopdevice=true
            STORAGE_SOURCE=""
        else
            STORAGE_SOURCE=" source=${STORAGE_SOURCE}"
        fi

        if [ "x${STORAGE_SIZE}" = "xnull" ]; then
            STORAGE_SIZE=""
        else
            STORAGE_SIZE=" size=${STORAGE_SIZE}"

        fi
        # echo ${STORAGE_NAME}
        # echo ${STORAGE_DRIVER}
        # echo ${STORAGE_SOURCE}
        # echo ${STORAGE_SIZE}

        # exit
        local STORAGES=()
        get_storages "${PROJECT_NAME}"

        echo "### Creating storage ${STORAGE_NAME} in the ${PROJECT_NAME} project..."
        if ! is_in_array "${STORAGE_NAME}" "${STORAGES[@]}"; then

            if is_cluster; then
                CLUSTER_MEMBERS=()
                get_cluster_member

                for ((r = 0; r < ${#CLUSTER_MEMBERS[@]}; r++)); do
                    echo "### Creating storage ${STORAGE_NAME} in the ${PROJECT_NAME} project on member ${CLUSTER_MEMBERS[$r]}..."
                    lxc storage create "${STORAGE_NAME}" "${STORAGE_DRIVER}" ${STORAGE_SOURCE} ${STORAGE_SIZE} --project "${PROJECT_NAME}" --target="${CLUSTER_MEMBERS[$r]}" 2>"logs/${PROJECT_NAME}/lxc.log"
                    if [ $? -eq 0 ]; then
                        echo "##### [OK] Storage ${STORAGE_NAME} was created in member ${CLUSTER_MEMBERS[$r]}."
                    else
                        echo "##### [$?] Error creating storage ${STORAGE_NAME} in member ${CLUSTER_MEMBERS[$r]}."
                        exit $?
                    fi
                done
            fi

            #lxc storage create "${STORAGE_NAME}" "${STORAGE_DRIVER}" ${STORAGE_SOURCE} ${STORAGE_SIZE} --project "${PROJECT_NAME}" --target terra
            #lxc storage create "${STORAGE_NAME}" "${STORAGE_DRIVER}" ${STORAGE_SOURCE} ${STORAGE_SIZE} --project "${PROJECT_NAME}" --target lxdn1
            echo "#### Creating storage ${STORAGE_NAME} for project ${PROJECT_NAME}..."
            lxc storage create "${STORAGE_NAME}" "${STORAGE_DRIVER}" --project "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The storage was created successfully."
            else
                echo "##### [$?] Error creating storage."
                exit $?
            fi

        else
            echo "#### [OK] Storage already exists."
        fi

    done
    echo "## END Creating storage for project in LXC."

    #exit
    #lxc storage list --project "${PROJECT_NAME}"
    echo
}

create_storage_volumes() {

    echo "## Creating storage volumes for project."
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")

        local profile_file="${LXC_GENERATED_CONFIGS_DIR}/profiles/${PROFILE_NAME}.yaml"
        #echo $profile_file

        #local PROFILE_DEVICES=$(yq e ".devices" "${profile_file}")
        #echo "${PROFILE_DEVICES}"

        local PROFILE_DEVICES_LENGTH=$(yq -r ".devices | keys | length" "${profile_file}")
        #echo "${PROFILE_DEVICES_LENGTH}"

        for ((o = 0; o < ${PROFILE_DEVICES_LENGTH}; o++)); do
            local type=$(yq -r ".devices | keys | .[$o]" "${profile_file}")
            local DEVICE_NAME=$(yq -r ".devices.${type}.type" "${profile_file}")
            if [ "x${DEVICE_NAME}" != "xdisk" ]; then
                continue
            fi

            local DEVICE_POOL=$(yq -r ".devices.${type}.pool" "${profile_file}")
            if [ "x${DEVICE_POOL}" = "xdefault" ]; then
                continue
            fi

            local DEVICE_SOURCE=$(yq -r ".devices.${type}.source" "${profile_file}")
            # if [ "x${DEVICE_POOL}" = "xdefault" ]; then
            #     continue
            # fi
            #echo $DEVICE_NAME
            #echo $DEVICE_POOL
            #echo $DEVICE_SOURCE

            local VOLUMES=()
            get_volumes "${PROJECT_NAME}" ${DEVICE_POOL}

            echo "### Creating a storage volume ${DEVICE_SOURCE} on storage ${DEVICE_POOL}..."
            if ! is_in_array "${DEVICE_SOURCE}" "${VOLUMES[@]}"; then
                lxc storage volume create "${DEVICE_POOL}" "${DEVICE_SOURCE}" --project "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
                if [ $? -eq 0 ]; then
                    echo "#### [OK] The storage volume was created successfully."
                else
                    echo "#### [$?] Error creating the storage volume."
                    exit $?
                fi
            else
                echo "#### [OK] The storage volume already exists."
            fi

            #lxc storage volume list ${DEVICE_POOL} --project "${PROJECT_NAME}"

        done
    done
    echo "## END Creating storage volumes for project."
    echo

    #lxc storage create NAME dir --project ncdc3 --target terra
    #lxc storage create NAME dir --project ncdc3 --target lxdn1
    #lxc storage create NAME dir --project ncdc3
    #lxc storage volume create NAME ncdc3 --project ncdc3
    #echo aaaa
}

create_lxc_projects() {
    local PROJECTS=()
    get_projects
    local PROJECT_NAME=$(yq e '.config.lxd.projectName' "${CONFIG_FILE}")
    echo "### Creating the '${PROJECT_NAME}' project in LXC."
    if ! is_in_array "${PROJECT_NAME}" "${PROJECTS[@]}"; then
        lxc project create "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] Project created"
        else
            echo "#### [$?] Error creating project"
            exit $?
        fi
    else
        echo "#### [OK] Project exists"
    fi
    echo
}

create_lxc_bridges() {
    if ! [ -f "projects/${PROJECT_NAME}/lxc/bridge/bridge.yaml" ]; then
        return
    fi

    echo "### Creating bridge ${bridge_name} for project ${PROJECT_NAME}..."
    evolve_templates "projects/${PROJECT_NAME}/lxc/bridge/bridge.yaml" "${LXC_GENERATED_CONFIGS_DIR}/bridge/bridge.yaml"
    local bridge_name=$(yq e ".name" "${LXC_GENERATED_CONFIGS_DIR}/bridge/bridge.yaml")

    if [ ${#bridge_name} -gt 15 ]; then
        echo "#### Error creating the bridge ${bridge_name}, the bridge name cannot be longer than 15 characters."
        exit 255
    fi

    #echo ${bridge_name}

    if ! get_bridge "${bridge_name}"; then

        if is_cluster; then
            CLUSTER_MEMBERS=()
            get_cluster_member

            for ((o = 0; o < ${#CLUSTER_MEMBERS[@]}; o++)); do
                echo "#### Creating bridge "${bridge_name}" for project ${PROJECT_NAME} on member ${CLUSTER_MEMBERS[$o]}..."
                lxc --project "${PROJECT_NAME}" network create "${bridge_name}" --target="${CLUSTER_MEMBERS[$o]}" 2>"logs/${PROJECT_NAME}/lxc.log"
                if [ $? -eq 0 ]; then
                    echo "##### [OK] The bridge was created on member ${CLUSTER_MEMBERS[$o]}."
                else
                    echo "##### [$?] Error creating the bridge on member ${CLUSTER_MEMBERS[$o]}."
                    exit $?
                fi
            done
        fi

        lxc --project "${PROJECT_NAME}" network create "${bridge_name}" 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] Bridge created"
        else
            echo "#### [$?] Error creating bridge"
            exit $?
        fi
    else
        echo "#### [OK] Bridge exists"
    fi

    lxc --project "${PROJECT_NAME}" network edit "${bridge_name}" < <(cat "${LXC_GENERATED_CONFIGS_DIR}/bridge/bridge.yaml") 2>"logs/${PROJECT_NAME}/lxc.log"
    if [ $? -eq 0 ]; then
        echo "#### [OK] Bridge edited"
    else
        echo "#### [$?] Error Bridge edite"
        exit $?
    fi
    echo
}

create_lxc_profiles() {
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")

        local PROFILES=()
        get_profiles "${PROJECT_NAME}"

        echo "### Creating the '${PROFILE_NAME}' profile in the '${PROJECT_NAME}' LXC project."
        if ! is_in_array "${PROFILE_NAME}" "${PROFILES[@]}"; then
            lxc --project "${PROJECT_NAME}" profile create "${PROFILE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Profile created"
            else
                echo "#### [$?] Error creating profile"
                exit $?
            fi
        else
            echo "#### [OK] Profile exists"
        fi

        echo "### Applying the settings in the '${PROFILE_NAME}' profile in the '${PROJECT_NAME}' LXC project."
        evolve_templates $(get_lxc_profile_path "projects/${PROJECT_NAME}/lxc/profiles/${PROFILE_NAME}.yaml") "${LXC_GENERATED_CONFIGS_DIR}/profiles/${PROFILE_NAME}.yaml"

        lxc --project "${PROJECT_NAME}" profile edit "${PROFILE_NAME}" < <(cat ${LXC_GENERATED_CONFIGS_DIR}/profiles/${PROFILE_NAME}.yaml) 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] Settings applied"
        else
            echo "#### [$?] Error applying profile settings"
            exit $?
        fi
    done
    echo
}

create_lxc_instances() {

    local target=""

    if is_cluster; then
        if ! [ -z "${PROJECT_TARGET}" ]; then
            target=" --target=${PROJECT_TARGET}"
        fi
    fi
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")
        local INSTANCE_IMAGE=$(yq e ".config.instances[$i].lxd.image" "${CONFIG_FILE}")

        CONTAINERS=()
        get_containers "${PROJECT_NAME}"

        echo "### Creating the '${INSTANCE_NAME}' container in the '${PROJECT_NAME}' LXC project."
        if ! is_in_array "${INSTANCE_NAME}" "${CONTAINERS[@]}"; then
            echo "#### With the image '${INSTANCE_IMAGE}'."
            echo "#### With the profile '${PROFILE_NAME}'."
            lxc --project "${PROJECT_NAME}" launch "${INSTANCE_IMAGE}" "${INSTANCE_NAME}" --profile "${PROFILE_NAME}" ${target} 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Instance created"
            else
                echo "#### [$?] Error creating instance"
                exit $?
            fi
        else
            echo "#### [OK] Instance exists"
        fi
    done
    echo
}

delete_lxc_images() {

    echo "### Deleting images associated with the project"
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local IMAGES=()
        get_images "${PROJECT_NAME}"

        for ((o = 0; o < ${#IMAGES[@]}; o++)); do
            echo "#### Deleting image '${IMAGES[$o]}' in project '${PROJECT_NAME}' LXC."
            if is_in_array "${IMAGES[$o]}" "${IMAGES[@]}"; then
                lxc --project "${PROJECT_NAME}" image delete "${IMAGES[$o]}" 2>"logs/${PROJECT_NAME}/lxc.log"
                if [ $? -eq 0 ]; then
                    echo "##### [OK] Image deleted"
                else
                    echo "##### [$?] Error deleting image"
                    $FORCE || exit $?
                fi
            else
                echo "##### [OK] Image do not exist"
            fi
        done
    done
    echo
}

delete_lxc_bridges() {

    if ! [ -f "projects/${PROJECT_NAME}/lxc/bridge/bridge.yaml" ]; then
        return
    fi

    echo "### Deleting bridge ${bridge_name} in project '${PROJECT_NAME}'."
    if ! [ -f "${LXC_GENERATED_CONFIGS_DIR}/bridge/bridge.yaml" ]; then
        echo "#### [OK] Bridge generated file do not exists"
        echo
        return 0
    fi

    local bridge_name=$(yq e ".name" "${LXC_GENERATED_CONFIGS_DIR}/bridge/bridge.yaml")
    echo "### Deleting bridge ${bridge_name} in project '${PROJECT_NAME}'."
    if get_bridge "${bridge_name}"; then
        lxc network delete "${bridge_name}" 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] Bridge deleted"
        else
            echo "#### [$?] Error deleting the bridge"
            $FORCE || exit $?
        fi
    else
        echo "#### [OK] Bridge do not exists"
    fi
    echo
    # fi
}

delete_lxc_profiles() {
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")
        local INSTANCE_IMAGE=$(yq e ".config.instances[$i].lxd.image" "${CONFIG_FILE}")

        local PROFILES=()
        get_profiles "${PROJECT_NAME}"

        echo "### Deleting profile '${PROFILE_NAME}' in project '${PROJECT_NAME}' LXC."
        if is_in_array "${PROFILE_NAME}" "${PROFILES[@]}"; then
            lxc --project "${PROJECT_NAME}" profile delete "${PROFILE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Profile deleted"
            else
                echo "#### [$?] Error deleting profile"
                $FORCE || exit $?
            fi
        else
            echo "#### [OK] Profile does not exist"
        fi
    done
    echo
}

delete_generated_files() {

    rm -fr "${LXC_GENERATED_CONFIGS_DIR}"
    rm -fr "${K8S_GENERATED_CONFIGS_DIR}"
    #rm -fr "logs/${PROJECT_NAME}"
}

destroy() {

    echo -e "\n# Destroying LXD's '${PROJECT_NAME}' project...\n"

    destroyinstances
    delete_lxc_profiles
    delete_lxc_images
    delete_lxc_bridges

    delete_storage_volumes
    delete_storage

    local PROJECTS=()
    get_projects

    echo "### Deleting the '${PROJECT_NAME}' project in LXC."
    if is_in_array "${PROJECT_NAME}" "${PROJECTS[@]}"; then
        PROJECTS+=("${PROJECT_NAME}")
        lxc project delete "${PROJECT_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] Project deleted"
        else
            echo "#### [$?] Error deleting project"
            $FORCE || exit $?
        fi
    else
        echo "#### [OK] Project do not exists"
    fi

    if [ $DELETE_GENERATED = true ]; then
        delete_generated_files
    fi
    echo -e "\n# END Destroying LXD's '${PROJECT_NAME}' project...\n"
}

destroyinstances() {
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")
        local INSTANCE_IMAGE=$(yq e ".config.instances[$i].lxd.image" "${CONFIG_FILE}")

        CONTAINERS=()
        get_containers "${PROJECT_NAME}"

        echo "### Destroying the '${INSTANCE_NAME}' container in the '${PROJECT_NAME}' LXC project."
        if is_in_array "${INSTANCE_NAME}" "${CONTAINERS[@]}"; then
            lxc --project "${PROJECT_NAME}" delete --force "${INSTANCE_NAME}" 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "#### [OK] Instance deleted"
            else
                echo "#### [$?] Error deleting instance"
                $FORCE || exit $?
            fi
        else
            echo "#### [OK] Instance do not exists"
        fi
    done
    echo
}

build_bootstrap_payload_content() {

    cat <<EOF
export PROJECT_NAME=${PROJECT_NAME};
export INSTANCES_LENGTH=${INSTANCES_LENGTH};
export K8S_VERSION=${K8S_VERSION};
export K8S_API_ENDPOINT_DOMAIN=${K8S_API_ENDPOINT_DOMAIN};
export K8S_CLUSTER_NAME=${K8S_CLUSTER_NAME};
export K8S_POD_SUBNET=${K8S_POD_SUBNET};
export PROJECT_PROFILES_NAME=${PROJECT_PROFILES_NAME};
export PROJECT_INSTANCES_NAME=${PROJECT_INSTANCES_NAME};
export PROJECT_INSTANCES_IMAGES=${PROJECT_INSTANCES_IMAGES};
export PROJECT_INSTANCES_TYPE=${PROJECT_INSTANCES_TYPE};
export CURRENT_INSTANCE_NAME=${CURRENT_INSTANCE_NAME};
export CURRENT_INSTANCE_TYPE=${CURRENT_INSTANCE_TYPE};
export CURRENT_PROFILE_NAME=${CURRENT_PROFILE_NAME};
export CURRENT_INSTANCE_IMAGE=${CURRENT_INSTANCE_IMAGE};
export CURRENT_INSTANCE_INDEX=${CURRENT_INSTANCE_INDEX};
export CURRENT_INSTANCE_IP=${CURRENT_INSTANCE_IP};
export K8S_MASTER_INSTANCE_NAME=${K8S_MASTER_INSTANCE_NAME};
export K8S_MASTER_INSTANCE_IP=${K8S_MASTER_INSTANCE_IP};

EOF

    cat $(get_kubernetes_bootstrap_path "projects/${PROJECT_NAME}/kubernetes/bootstrap/${INSTANCE_NAME}.sh")
}

build_postboot_payload_content() {

    cat <<EOF
export PROJECT_NAME=${PROJECT_NAME};
export INSTANCES_LENGTH=${INSTANCES_LENGTH};
export K8S_VERSION=${K8S_VERSION};
export K8S_API_ENDPOINT_DOMAIN=${K8S_API_ENDPOINT_DOMAIN};
export K8S_CLUSTER_NAME=${K8S_CLUSTER_NAME};
export K8S_POD_SUBNET=${K8S_POD_SUBNET};
export PROJECT_PROFILES_NAME=${PROJECT_PROFILES_NAME};
export PROJECT_INSTANCES_NAME=${PROJECT_INSTANCES_NAME};
export PROJECT_INSTANCES_IMAGES=${PROJECT_INSTANCES_IMAGES};
export PROJECT_INSTANCES_TYPE=${PROJECT_INSTANCES_TYPE};
export CURRENT_INSTANCE_NAME=${CURRENT_INSTANCE_NAME};
export CURRENT_INSTANCE_TYPE=${CURRENT_INSTANCE_TYPE};
export CURRENT_PROFILE_NAME=${CURRENT_PROFILE_NAME};
export CURRENT_INSTANCE_IMAGE=${CURRENT_INSTANCE_IMAGE};
export CURRENT_INSTANCE_INDEX=${CURRENT_INSTANCE_INDEX};
export CURRENT_INSTANCE_IP=${CURRENT_INSTANCE_IP};
export K8S_MASTER_INSTANCE_NAME=${K8S_MASTER_INSTANCE_NAME};
export K8S_MASTER_INSTANCE_IP=${K8S_MASTER_INSTANCE_IP};


EOF

    cat $(get_kubernetes_postboot_path "projects/${PROJECT_NAME}/kubernetes/postboot/postboot.sh")
}

evolve_templates() {

    sed \
        -e "s?\${K8S_MASTER_INSTANCE_NAME}?${K8S_MASTER_INSTANCE_NAME}?" \
        -e "s?\${K8S_MASTER_INSTANCE_IP}?${K8S_MASTER_INSTANCE_IP}?" \
        -e "s?\${CA_CERT_HASH}?${CA_CERT_HASH}?" \
        -e "s?\${CA_DATA_B64}?${CA_DATA_B64}?" \
        -e "s?\${CLIENT_CERT_B64}?${CLIENT_CERT_B64}?" \
        -e "s?\${CLIENT_KEY_B64}?${CLIENT_KEY_B64}?" \
        -e "s?\${KUBEADM_TOKEN}?${KUBEADM_TOKEN}?" \
        -e "s?\${K8S_POD_SUBNET}?${K8S_POD_SUBNET}?" \
        -e "s/\${PROJECT_NAME}/${PROJECT_NAME}/" \
        -e "s?\${INSTANCES_LENGTH}?${INSTANCES_LENGTH}?" \
        -e "s/\${K8S_VERSION}/${K8S_VERSION}/" \
        -e "s/\${K8S_API_ENDPOINT}/${K8S_API_ENDPOINT}/" \
        -e "s/\${K8S_API_ENDPOINT_DOMAIN}/${K8S_API_ENDPOINT_DOMAIN}/" \
        -e "s/\${K8S_CLUSTER_NAME}/${K8S_CLUSTER_NAME}/" \
        -e "s/\${PROJECT_PROFILES_NAME}/${PROJECT_PROFILES_NAME}/" \
        -e "s/\${PROJECT_INSTANCES_NAME}/${PROJECT_INSTANCES_NAME}/" \
        -e "s/\${PROJECT_INSTANCES_IMAGES}/${PROJECT_INSTANCES_IMAGES}/" \
        -e "s/\${PROJECT_INSTANCES_TYPE}/${PROJECT_INSTANCES_TYPE}/" \
        -e "s/\${CURRENT_INSTANCE_NAME}/${CURRENT_INSTANCE_NAME}/" \
        -e "s/\${CURRENT_INSTANCE_TYPE}/${CURRENT_INSTANCE_TYPE}/" \
        -e "s/\${CURRENT_PROFILE_NAME}/${CURRENT_PROFILE_NAME}/" \
        -e "s/\${CURRENT_INSTANCE_IMAGE}/${CURRENT_INSTANCE_IMAGE}/" \
        -e "s/\${CURRENT_INSTANCE_INDEX}/${CURRENT_INSTANCE_INDEX}/" \
        -e "s/\${CURRENT_INSTANCE_IP}/${CURRENT_INSTANCE_IP}/" "$1" >"$2"

    return $?

}

generate_kubernetes_token() {
    echo $(printf '%s' $(echo "$RANDOM" | md5sum) | cut -c 1-6).$(printf '%s' $(echo "$RANDOM" | md5sum) | cut -c 1-16)
}

apply_cni_configs() {

    local cni_directory="projects/${PROJECT_NAME}/kubernetes/templates/cni"

    if ! [ -d "${cni_directory}" ]; then
        cni_directory="projects/default/kubernetes/templates/cni"
    fi

    local IFS=$(echo -en "\n\b")
    local templates=$(find "${cni_directory}" -type f | sort 2>/dev/null)
    local templates_num=$(find "${cni_directory}" -type f 2>/dev/null | wc -l)

    if [ ${templates_num} -lt 1 ]; then
        return 0
    fi
    echo "#### Applying CNI templates to Kubernetes..."

    for TEMPLATE in ${templates}; do
        local file_name=$(basename ${TEMPLATE})

        echo "##### Processing the ${file_name} template"
        evolve_templates "${TEMPLATE}" "${K8S_GENERATED_CONFIGS_DIR}/cni/${file_name}"

        verify_resources "${K8S_GENERATED_CONFIGS_DIR}/cni/${file_name}"

        echo "##### Applying the ${file_name} template to Kubernetes."
        cat "${K8S_GENERATED_CONFIGS_DIR}/cni/${file_name}" | lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl apply --server-side --force-conflicts -f - >>"logs/${PROJECT_NAME}/cni.log" 2>&1
        if [ $? -eq 0 ]; then
            echo "###### [OK] The template was applied successfully."
            wait_phase
        else
            echo "###### [$?] Error applying the template."
            exit 255
        fi
    done
}

apply_csi_configs() {

    local csi_directory="projects/${PROJECT_NAME}/kubernetes/templates/csi"

    if ! [ -d "${csi_directory}" ]; then
        csi_directory="projects/default/kubernetes/templates/csi"
    fi

    local IFS=$(echo -en "\n\b")
    local templates=$(find "${csi_directory}" -type f | sort 2>/dev/null)
    local templates_num=$(find "${csi_directory}" -type f 2>/dev/null | wc -l)

    if [ ${templates_num} -lt 1 ]; then
        return 0
    fi
    echo "#### Applying CSI templates to Kubernetes..."

    for TEMPLATE in ${templates}; do
        local file_name=$(basename ${TEMPLATE})

        echo "##### Processing the ${file_name} template"
        evolve_templates "${TEMPLATE}" "${K8S_GENERATED_CONFIGS_DIR}/csi/${file_name}"

        verify_resources "${K8S_GENERATED_CONFIGS_DIR}/csi/${file_name}"

        echo "##### Applying the ${file_name} template to Kubernetes."
        cat "${K8S_GENERATED_CONFIGS_DIR}/csi/${file_name}" | lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl apply --server-side --force-conflicts -f - >>"logs/${PROJECT_NAME}/csi.log" 2>&1
        if [ $? -eq 0 ]; then
            echo "###### [OK] The template was applied successfully."
            wait_phase
        else
            echo "###### [$?] Error applying the template."
            exit 255
        fi
    done
}

wait_phase() {
    #   for i in $(kubectl api-resources --verbs=list --namespaced -o name | grep -v "events.events.k8s.io" | grep -v "events" | sort | uniq); do
    #     echo "Resource:" $i
    #     kubectl -A get --ignore-not-found ${i}
    #   done
    #   --template "{{ range (index .status.loadBalancer.ingress 0) }}{{.}}{{ end }}"
    # kubectl get pod -o custom-columns=:.metadata.name  --no-headers
    # kubectl get secret wordpress -o yaml --template='{{index .metadata.labels}}'
    # kubectl get pod -A -o custom-columns=:.status.phase --no-headers

    # kubectl wait --for=condition=Ready nodes --all --timeout=600s
    # kubectl wait pod --all --for=condition=Ready -A --timeout=600s
    # kubectl wait --for condition=Established --all CustomResourceDefinition -A

    #sleep 5
    #kubectl wait --for=condition=Ready nodes --all --timeout=600s
    #kubectl wait pod --all --for=condition=Ready -A --timeout=600s
    #kubectl wait --for condition=Established --all CustomResourceDefinition -A

    # lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl wait CustomResourceDefinition --all --for=condition=Established -A --timeout=${MAX_WAIT_SECONDS}s >>"logs/${PROJECT_NAME}/others-apply.log" 2>&1
    # lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl wait pod --all --for=condition=Ready -A --timeout=${MAX_WAIT_SECONDS}s >>"logs/${PROJECT_NAME}/others-apply.log" 2>&1

    # return


    local t=0
    while [ $t -le ${MAX_WAIT_SECONDS} ]; do
        if [ ${WAIT_CDRs} = true ]; then
            #echo "#### This template has Custom Resource Definitions that need to be applied."
            lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl wait CustomResourceDefinition --all --for=condition=Established -A --timeout=5s >>"logs/${PROJECT_NAME}/others-apply.log" 2>&1
            if [ $? -eq 0 ]; then
                WAIT_CDRs=false
            else
                continue
            fi
        fi
        lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl wait pod --all --for=condition=Ready -A --timeout=5s >>"logs/${PROJECT_NAME}/others-apply.log" 2>&1
        if [ $? -eq 0 ]; then
            return
        fi
        sleep 1
        t=$((t + 1))
    done
}

verify_resources() {
    WAIT_CDRs=false
    #echo "$1"
    local i=0
    local DOCs_LENGTH=$(yq ea '[.] | length' "$1")
    for ((i = 0; i < ${DOCs_LENGTH}; i++)); do
        local KIND=""
        KIND=$(yq "select(document_index == ${i})" "$1" | yq '.kind')
        if [ $? -eq 0 ]; then
            case "${KIND}" in
            CustomResourceDefinition)
                WAIT_CDRs=true
                ;;
            esac
        fi
    done
}

apply_others_configs() {

    local others_apply_directory="projects/${PROJECT_NAME}/kubernetes/templates/others/apply"
    if ! [ -d "${others_apply_directory}" ]; then
        others_apply_directory="projects/default/kubernetes/templates/others/apply"
    fi
    if ! [ -d "${others_apply_directory}" ]; then
        return
    fi

    local IFS=$(echo -en "\n\b")
    local templates=$(find "${others_apply_directory}" -type f | sort 2>/dev/null)
    local templates_num=$(find "${others_apply_directory}" -type f 2>/dev/null | wc -l)

    if [ ${templates_num} -lt 1 ]; then
        return 0
    fi
    echo "### Applying Others templates to Kubernetes..."
    for TEMPLATE in ${templates}; do
        local file_name=$(basename ${TEMPLATE})

        echo "#### Processing the ${file_name} template"
        evolve_templates "${TEMPLATE}" "${K8S_GENERATED_CONFIGS_DIR}/others/apply/${file_name}"

        verify_resources "${K8S_GENERATED_CONFIGS_DIR}/others/apply/${file_name}"
        #echo ${TEMPLATE}

        echo "#### Applying the ${file_name} template to Kubernetes."
        cat "${K8S_GENERATED_CONFIGS_DIR}/others/apply/${file_name}" | lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl apply --server-side --force-conflicts -f - >>"logs/${PROJECT_NAME}/others-apply.log" 2>&1
        if [ $? -eq 0 ]; then
            echo "##### [OK] The template was applied successfully."
            wait_phase
        else
            echo "##### [$?] Error applying the template."
            exit 255
        fi

    done
    echo
}

create_project_log_dir() {
    PROJECT_LOG_DIR="logs/${PROJECT_NAME}"
    echo "#### Creating the ${PROJECT_LOG_DIR} directory for logs"
    mkdir -p "${PROJECT_LOG_DIR}"
    if [ $? -eq 0 ]; then
        echo "##### [OK] The ${PROJECT_LOG_DIR} directory for the logs has been created"
    else
        echo "##### [$?] Error creating ddd directory for logs"
        exit 255
    fi
}
create_instance_log_dir() {

    echo "## Creating the logs/${PROJECT_NAME}/{${1}} directory for logs"
    eval "mkdir -p logs/${PROJECT_NAME}/{${1}}"
    if [ $? -eq 0 ]; then
        echo "### [OK] The logs/${PROJECT_NAME}/{${1}} directory for the logs has been created"
    else
        echo "### [$?] Error creating ddd directory for logs"
        exit 255
    fi
    echo
}

create_generated_dirs() {
    echo "## Creating the directories for the generated config files to kubernetes"

    mkdir -p projects/${PROJECT_NAME}/{kubernetes/{kubeconfig,generated-configs/{cni,csi,init,join,others/{apply,create}}},lxc/generated-configs/{bridge,profiles,storage}}
    if [ $? -eq 0 ]; then
        echo "### [OK] The directories for the generated config files to kubernetes has been created"
    else
        echo "### [$?] Error creating directories for the generated config files to kubernetes"
        exit 255
    fi
    echo
}

get_node_stat() {
    local node=""
    node=$(lxc --project "${PROJECT_NAME}" exec "${K8S_MASTER_INSTANCE_NAME}" -- kubectl get no "$1" -o wide -o yaml 2>/dev/null)
    local node_stat=$?
    echo "${node}" | grep 'type: Ready' >>"${INSTANCE_LOG_DIR}/install.log" 2>&1
    if [ $? -eq 0 ] && [ $node_stat -eq 0 ]; then
        return 0
    fi
    return 1
}

provision_kubernetes_cluster() {
    local i=0
    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")
        local INSTANCE_IMAGE=$(yq e ".config.instances[$i].lxd.image" "${CONFIG_FILE}")
        local INSTANCE_TYPE=$(yq e ".config.instances[$i].kubernetes.type" "${CONFIG_FILE}")

        CURRENT_INSTANCE_NAME=${INSTANCE_NAME}
        CURRENT_INSTANCE_TYPE=${INSTANCE_TYPE}
        CURRENT_INSTANCE_INDEX=${i}
        CURRENT_PROFILE_NAME=${PROFILE_NAME}
        CURRENT_INSTANCE_IMAGE=${INSTANCE_IMAGE}
        CURRENT_INSTANCE_IP=$(get_instance_ip "${PROJECT_NAME}" "${INSTANCE_NAME}")
        INSTANCE_LOG_DIR=logs/${PROJECT_NAME}/${INSTANCE_NAME}

        K8S_API_ENDPOINT=${INSTANCE_NAME}.${K8S_API_ENDPOINT_DOMAIN}
        if [ ${K8S_KUBE_CONFIG_ENDPOINT_USE_IP} = true ]; then
            K8S_API_ENDPOINT=${CURRENT_INSTANCE_IP}
        fi

        if [[ "${INSTANCE_TYPE}" == "master" ]]; then
            K8S_MASTER_INSTANCE_NAME=${INSTANCE_NAME}
            K8S_MASTER_INSTANCE_IP=${CURRENT_INSTANCE_IP}

            echo "### Configuring the master plane: ${INSTANCE_NAME}"

            if [ $FORCE = false ] && get_node_stat "${INSTANCE_NAME}"; then
                echo "#### [OK] The master plane has already successfully initialized"
                echo "### END Configuring the master plane: ${INSTANCE_NAME}"
                echo
                continue
            fi

            echo "#### Wait a maximum of 360s until the container has a network, so we can proceed."
            if is_up 360 "${PROJECT_NAME}" "${INSTANCE_NAME}"; then
                echo "##### The container is active and has the network configured"
            else
                echo "##### ABORT: The container is not active and/or has not the network configured"
                exit 255
            fi

            echo "#### Resolving the master plane domain: ${INSTANCE_NAME}.${K8S_API_ENDPOINT_DOMAIN}"
            echo "nslookup '${INSTANCE_NAME}.${K8S_API_ENDPOINT_DOMAIN}' | grep 'Address:' | grep '${CURRENT_INSTANCE_IP}'" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" bash >>"${INSTANCE_LOG_DIR}/install.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### It is possible to resolve the domain to the machine's IP:" ${CURRENT_INSTANCE_IP}
            else
                echo "##### Unable to resolve the domain to the machine's IP: " ${CURRENT_INSTANCE_IP}
                exit 255
            fi

            TEMPLATE_DIR="projects/${PROJECT_NAME}/kubernetes/templates"

            echo "#### Installing the necessary software in the container, such as kubernetes, containerd and some dependent utilities."
            build_bootstrap_payload_content "${PROJECT_NAME}" "${INSTANCE_NAME}" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash >>"${INSTANCE_LOG_DIR}/bootstrap.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### [OK] The required software has been installed"
            else
                echo "##### [$?] Errors appeared when installing the necessary software"
                exit 255
            fi

            echo "#### Generating a token in Kubernetes"
            KUBEADM_TOKEN=$(generate_kubernetes_token)

            kadminittemplate=$(get_kubernetes_template_path "${TEMPLATE_DIR}/init/kubeadm-init-config.yaml")
            echo "#### Processing the ${kadminittemplate} template"
            evolve_templates "${kadminittemplate}" "${K8S_GENERATED_CONFIGS_DIR}/init/kubeadm-init-config.yaml"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The "${kadminittemplate}" template was processed successfully"
            else
                echo "##### [$?] Error processing "${kadminittemplate}" template"
                exit 255
            fi

            echo "#### Copying the '${K8S_GENERATED_CONFIGS_DIR}/init/kubeadm-init-config.yaml' configuration file to ${INSTANCE_NAME}"
            lxc --project "${PROJECT_NAME}" file push -p ${K8S_GENERATED_CONFIGS_DIR}/init/kubeadm-init-config.yaml ${INSTANCE_NAME}/root/kubeadm-init-config.yaml --uid 0 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The '${K8S_GENERATED_CONFIGS_DIR}/init/kubeadm-init-config.yaml' configuration file has been successfully copied to ${INSTANCE_NAME}"
            else
                echo "##### [$?] Error when copying '${K8S_GENERATED_CONFIGS_DIR}/init/kubeadm-init-config.yaml' configuration file to ${INSTANCE_NAME}"
                exit 255
            fi

            echo "#### Download the Kubernetes base images"
            echo "kubeadm config images pull --kubernetes-version v${K8S_VERSION}" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash >>"${INSTANCE_LOG_DIR}/kubeadminit.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### [OK] The images were downloaded successfully"
            else
                echo "##### [$?] Error when downloading images"
                exit 255
            fi

            echo "#### Initializing the master plane"
            lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- kubeadm --v=5 init --ignore-preflight-errors=all --config /root/kubeadm-init-config.yaml >>"${INSTANCE_LOG_DIR}/kubeadminit.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### [OK] The master plane has been successfully initialized"
            else
                echo "##### [$?] Error initializing the master plane"
                exit 255
            fi

            echo "mkdir -p /root/.kube; cp /etc/kubernetes/admin.conf /root/.kube/config; chown $(id -u):$(id -g) /root/.kube/config" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash

            CA_CERT_HASH=$(echo "openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* /sha256:/'" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash)
            CA_DATA_B64=$(echo "cat /etc/kubernetes/pki/ca.crt | base64 -w0" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash)
            CLIENT_CERT_B64=$(echo "cat /etc/kubernetes/pki/apiserver-kubelet-client.crt | base64 -w0" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash)
            CLIENT_KEY_B64=$(echo "cat /etc/kubernetes/pki/apiserver-kubelet-client.key | base64 -w0" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash)

            kubeconfigtemplate=$(get_kubernetes_template_path "${TEMPLATE_DIR}/kubeconfig/kubeadm-config.yaml")
            echo "#### Processing the ${kubeconfigtemplate} to access the master plane"
            echo "#### Creating ${KUBECTL_CONFIGS_DIR}/kubeconfig to access the master plane"
            evolve_templates "${kubeconfigtemplate}" "${K8S_GENERATED_KUBECONFIG_DIR}/config"

            kadmjointemplate=$(get_kubernetes_template_path "${TEMPLATE_DIR}/join/kubeadm-join-config.yaml")
            echo "#### Processing the ${kadmjointemplate} template to join workers"
            evolve_templates "${kadmjointemplate}" "${K8S_GENERATED_CONFIGS_DIR}/join/kubeadm-join-config.yaml"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The ${kadmjointemplate} template was processed successfully"
            else
                echo "##### [$?] Error processing ${kadmjointemplate} template"
                exit 255
            fi

            echo "### END Configuring the master plane: ${INSTANCE_NAME}"
        fi

        if [[ "${INSTANCE_TYPE}" == "worker" ]]; then
            echo "### Configuring the worker: ${INSTANCE_NAME}"

            if [ $FORCE = false ] && get_node_stat "${INSTANCE_NAME}"; then
                echo "#### [OK] The worker has already successfully joinedy"
                echo "### END Configuring the worker: ${INSTANCE_NAME}"
                echo
                continue
            fi

            echo "#### Wait a maximum of 360s until the container has a network, so we can proceed."
            if is_up 360 "${PROJECT_NAME}" "${INSTANCE_NAME}"; then
                echo "##### The container is active and has the network configured"
            else
                echo "##### ABORT: The container is not active and/or has not the network configured"
                exit 255
            fi

            echo "#### Installing the necessary software in the container, such as kubernetes, containerd and some dependent utilities."
            build_bootstrap_payload_content "${PROJECT_NAME}" "${INSTANCE_NAME}" | lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- bash >>"${INSTANCE_LOG_DIR}/bootstrap.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### [OK] The required software has been installed"
            else
                echo "##### [$?] Errors appeared when installing the necessary software"
                exit 255
            fi

            echo "#### Copying the '${K8S_GENERATED_CONFIGS_DIR}/join/kubeadm-join-config.yaml' configuration file to ${INSTANCE_NAME}"
            lxc --project "${PROJECT_NAME}" file push -p "${K8S_GENERATED_CONFIGS_DIR}/join/kubeadm-join-config.yaml" ${INSTANCE_NAME}/root/kubeadm-join-config.yaml --uid 0 2>"logs/${PROJECT_NAME}/lxc.log"
            if [ $? -eq 0 ]; then
                echo "##### [OK] The '${K8S_GENERATED_CONFIGS_DIR}/kubeadm-join-config.yaml' configuration file has been successfully copied to ${INSTANCE_NAME}"
            else
                echo "##### [$?] Error when copying '${K8S_GENERATED_CONFIGS_DIR}/kubeadm-join-config.yaml' configuration file to ${INSTANCE_NAME}"
                exit 255
            fi

            echo "#### Joining the worker to the cluster"
            lxc --project "${PROJECT_NAME}" exec "${INSTANCE_NAME}" -- kubeadm --v=5 join --config /root/kubeadm-join-config.yaml --ignore-preflight-errors=all >>"${INSTANCE_LOG_DIR}/kubeadmjoin.log" 2>&1
            if [ $? -eq 0 ]; then
                echo "##### [OK] The worker has been successfully joined"
            else
                echo "##### [$?] Error joining the worker"
                $FORCE || exit 255
            fi
            echo "### END Configuring the worker: ${INSTANCE_NAME}"
        fi
        echo
    done

            
    apply_cni_configs
    apply_csi_configs
    # Applying other templates to project xxxxx
    apply_others_configs

    # This script will run after basic kubernetes boots. With it we can install
    # and configure one or many applications for a given project. Using the
    # kubeconfig generated during kubernetes cluster initialization.
    echo "## Running the post boot script in project ${PROJECT_NAME}..."
    if [ -f "projects/${PROJECT_NAME}/kubernetes/postboot/postboot.sh" ]; then
        build_postboot_payload_content | bash >>"logs/${PROJECT_NAME}/postboot.log" 2>&1
        if [ $? -eq 0 ]; then
            echo "### [OK] The postboot script ran without problems."
        else
            echo "### [$?] An error status was returned when running the postboot script."
            exit 255
        fi
    else
        echo "### The project has no postboot scripts to apply."
    fi
    echo
}

copysshkey() {
    local i=0

    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")

        local PROJECTS=()
        get_projects

        echo "### Copying SSH public key to container '${INSTANCE_NAME}' in project '${PROJECT_NAME}' LXC."
        if is_up "120" "${PROJECT_NAME}" "${INSTANCE_NAME}"; then
            echo "#### The container is active and has the network configured"
        else
            echo "#### ABORT: The container is not active and/or has not the network configured"
            exit 255
        fi
        lxc --project "${PROJECT_NAME}" file push projects/SSH-KEY/lxkube.pub ${INSTANCE_NAME}/root/.ssh/authorized_keys --uid 0 2>"logs/${PROJECT_NAME}/lxc.log"
        if [ $? -eq 0 ]; then
            echo "#### [OK] SSH public key copied"
        else
            echo "#### [$?] Error coping SSH public key"
            exit $?
        fi
    done
    echo
}

provision() {
    echo -e "\n# Provisioning Kubernetes Cluster inside LXC containers\n"

    # Create project directories to save generated templates files
    create_generated_dirs

    # Create project instance logs directory
    create_instance_log_dir "${PROJECT_INSTANCES_NAME}"

    echo -e "## Provisioning LXC containers\n"

    create_lxc_projects

    create_lxc_bridges

    create_lxc_profiles

    create_storage
    create_storage_volumes

    create_lxc_instances

    copysshkey

    echo -e "## END of LXC provisioning\n"

    echo -e "## Provisioning Kubernetes clusters\n"

    provision_kubernetes_cluster

    echo -e "## END of Kubernetes cluster provisioning"
    echo -e "\n# END Provisioning Kubernetes Cluster inside LXC containers\n"

}

valid_config() {
    local error=0

    K8S_KUBE_CONFIG_ENDPOINT_USE_IP=$(yq e '.config.kubernetes.kubeConfigEndpointUseIP' "${CONFIG_FILE}")
    if [ "x${K8S_KUBE_CONFIG_ENDPOINT_USE_IP}" = "xfalse" ] || [ "x${K8S_KUBE_CONFIG_ENDPOINT_USE_IP}" = "xnull" ]; then
        K8S_KUBE_CONFIG_ENDPOINT_USE_IP=false
    else
        K8S_KUBE_CONFIG_ENDPOINT_USE_IP=true
    fi

    PROJECT_TARGET=$(yq e '.config.lxd.target' "${CONFIG_FILE}")
    if [ "x${PROJECT_TARGET}" = "xnull" ]; then
        PROJECT_TARGET=""
    fi

    PROJECT_NAME=$(yq e '.config.lxd.projectName' "${CONFIG_FILE}")
    if [ -z ${PROJECT_NAME} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))
    INSTANCES_LENGTH=$(yq e '.config.instances | length' "${CONFIG_FILE}")
    if [ -z ${INSTANCES_LENGTH} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))
    K8S_VERSION=$(yq e ".config.kubernetes.version" "${CONFIG_FILE}")
    if [ -z ${K8S_VERSION} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))
    K8S_API_ENDPOINT_DOMAIN=$(yq e '.config.kubernetes.controlPlaneEndpointDomain' "${CONFIG_FILE}")
    if [ -z ${K8S_API_ENDPOINT_DOMAIN} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))
    K8S_CLUSTER_NAME=$(yq e '.config.kubernetes.clusterName' "${CONFIG_FILE}")
    if [ -z ${K8S_CLUSTER_NAME} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))
    K8S_POD_SUBNET=$(yq e '.config.kubernetes.podSubnet' "${CONFIG_FILE}")
    if [ -z ${K8S_POD_SUBNET} ]; then
        error=$((error + $?))
    fi
    error=$((error + $?))

    local PROJECT_PROFILES_TMP=""
    local PROJECT_INSTANCES_NAME_TMP=""
    local PROJECT_INSTANCE_IMAGE_TMP=""
    local PROJECT_INSTANCE_TYPE_TMP=""

    local i=0
    for ((i = 0; i < ${INSTANCES_LENGTH}; i++)); do
        local PROFILE_NAME=$(yq e ".config.instances[$i].lxd.profile" "${CONFIG_FILE}")
        if [ -z ${PROFILE_NAME} ]; then
            error=$((error + $?))
        fi
        error=$((error + $?))
        PROJECT_PROFILES_TMP=${PROJECT_PROFILES_TMP}"${PROFILE_NAME}"
        if [ $((${i} + 1)) -lt ${INSTANCES_LENGTH} ]; then
            PROJECT_PROFILES_TMP=${PROJECT_PROFILES_TMP},
        fi

        local INSTANCE_NAME=$(yq e ".config.instances[$i].lxd.name" "${CONFIG_FILE}")
        if [ -z ${PROJECT_NAME} ]; then
            error=$((error + $?))
        fi
        error=$((error + $?))
        PROJECT_INSTANCES_NAME_TMP=${PROJECT_INSTANCES_NAME_TMP}"${INSTANCE_NAME}"
        if [ $((${i} + 1)) -lt ${INSTANCES_LENGTH} ]; then
            PROJECT_INSTANCES_NAME_TMP=${PROJECT_INSTANCES_NAME_TMP},
        fi

        local INSTANCE_IMAGE=$(yq e ".config.instances[$i].lxd.image" "${CONFIG_FILE}")
        if [ -z ${INSTANCE_IMAGE} ]; then
            error=$((error + $?))
        fi
        PROJECT_INSTANCE_IMAGE_TMP=${PROJECT_INSTANCE_IMAGE_TMP}"${INSTANCE_IMAGE}"
        if [ $((${i} + 1)) -lt ${INSTANCES_LENGTH} ]; then
            PROJECT_INSTANCE_IMAGE_TMP=${PROJECT_INSTANCE_IMAGE_TMP},
        fi

        error=$((error + $?))
        local INSTANCE_TYPE=$(yq e ".config.instances[$i].kubernetes.type" "${CONFIG_FILE}")
        if [ -z ${INSTANCE_TYPE} ]; then
            error=$((error + $?))
        fi
        error=$((error + $?))
        PROJECT_INSTANCE_TYPE_TMP=${PROJECT_INSTANCE_TYPE_TMP}"${INSTANCE_TYPE}"
        if [ $((${i} + 1)) -lt ${INSTANCES_LENGTH} ]; then
            PROJECT_INSTANCE_TYPE_TMP=${PROJECT_INSTANCE_TYPE_TMP},
        fi
    done

    PROJECT_PROFILES_NAME=${PROJECT_PROFILES_TMP}
    PROJECT_INSTANCES_NAME=${PROJECT_INSTANCES_NAME_TMP}
    PROJECT_INSTANCES_IMAGES=${PROJECT_INSTANCE_IMAGE_TMP}
    PROJECT_INSTANCES_TYPE=${PROJECT_INSTANCE_TYPE_TMP}

    # LXC dirs
    LXC_GENERATED_CONFIGS_DIR="projects/${PROJECT_NAME}/lxc/generated-configs"
    # kubernetes dirs
    K8S_GENERATED_CONFIGS_DIR="projects/${PROJECT_NAME}/kubernetes/generated-configs"
    # kubernetes kubeconfig
    K8S_GENERATED_KUBECONFIG_DIR="projects/${PROJECT_NAME}/kubernetes/kubeconfig"

    if [ $error -gt 0 ]; then
        echo error
        exit 255
    fi

}

parse_options() {
    OPTIND=2
    optspec=":-:"
    while getopts "$optspec" optchar "$@"; do
        case "${optchar}" in
        -)
            case "${OPTARG}" in
            force)
                FORCE=true
                ;;
            delete-generated)
                DELETE_GENERATED=true
                ;;
            config)
                val="${!OPTIND}"
                OPTIND=$(($OPTIND + 1))
                CONFIG_FILE=config/"${val}"
                ;;
            config=*)
                val=${OPTARG#*=}
                opt=${OPTARG%=$val}
                CONFIG_FILE=config/"${val}"
                ;;
            *)
                echo "Unknown option --${OPTARG}" >&2
                usage
                exit 255
                ;;
            esac
            ;;
        *)
            if [ "$OPTERR" != 1 ] || [ "${optspec:0:1}" = ":" ]; then
                echo "Non-option argument: '-${OPTARG}'" >&2
                usage
                exit 255
            fi
            ;;
        esac
    done
}

parse_options "$@"

if ! [ -f "${CONFIG_FILE}" ]; then
    usage
    exit
fi

valid_config

case "$1" in
provision)
    provision
    ;;
destroy)
    destroy
    ;;
stop)
    lxc_stop_containers
    ;;
start)
    lxc_start_containers
    ;;
pause)
    lxc_pause_containers
    ;;
restart)
    echo -e "\n## Restarting project instances...\n"
    lxc_stop_containers
    lxc_start_containers
    ;;
*)
    usage
    ;;
esac
